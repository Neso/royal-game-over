# Royal Game of War — Additional Feature Requests

## 1. Game Mode Selection

After the player selects **"Start Game"** from the main menu, a new **Game Mode** selection screen will be displayed.

### 1.1 Game Mode Screen

The Game Mode screen presents the player with two buttons/options:

1. **Hot Seat**

    * Both players share the same device.
    * Turn order and rules remain identical to the base Royal Game of War rules.
    * On each turn, the current player is indicated visually (e.g., highlight, banner, or label).

2. **Play Against AI**

    * Player 1 is controlled by the human user.
    * Player 2 is controlled by an AI module named **Jimmy**.
    * All rules of the game remain identical to the base game; only decision-making for Player 2 is automated.

### 1.2 Integration With Existing Flow

1. Main Menu → **Start Game** → **Game Mode Selection Screen**
2. Based on player choice:

    * **Hot Seat** → Initialize game with both `Player` instances as human-controlled.
    * **Play Against AI** → Initialize `Player 1` as human-controlled and `Player 2` as AI-controlled (via `AI` module).

---

## 2. AI Module — "Jimmy"

### 2.1 Module Overview

Create an **AI module** responsible for playing and selecting moves for **Player 2** when the mode **Play Against AI** is chosen.

* Module name: `AI` (or `JimmyAI`)
* AI player name (for UI): **Jimmy**
* The AI should be deterministic given the same board state and dice result unless optional randomness is later introduced.

### 2.2 Module Location & API

**File suggestion:**

* `src/game/AI/JimmyAI.js`

**Exported API (proposed):**

```js
// JimmyAI.js
export class JimmyAI {
  constructor(playerId, board, rulesEngine) {
    this.playerId = playerId;       // Player 2
    this.board = board;             // Reference to board state
    this.rulesEngine = rulesEngine; // Helper for validating moves
  }

  /**
   * Decide and return the move for the AI given:
   * - current board state
   * - dice result (number of moves available)
   */
  chooseMove(gameState, availableMoves) {
    // returns a Move object or null if no legal moves
  }
}
```

`availableMoves` is expected to be a pre-filtered list of legal moves generated by the game engine based on:

* Current AI pieces
* Dice result (total moves from dice roll)
* Game rules (entry conditions, movement path, exits, restrictions)

The **game loop** should:

1. Roll dice for the AI (Player 2).
2. Compute all legal moves for Player 2.
3. Pass these moves and full game state to `JimmyAI.chooseMove`.
4. Execute the move returned by `JimmyAI`.

---

## 3. AI Decision Logic (Priorities)

Jimmy’s move selection is based on a **priority hierarchy**. For each turn, the AI should:

1. Generate all **legal moves** for Player 2 from the current game state and dice result.
2. Classify these moves according to the following priorities.
3. Select a move from the highest non-empty priority group.

### 3.1 Priority Order

**Priority 1 — Enter Rosetta (bonus move)**
If the AI can **enter a Zeta. **  and such move is legal based on dice result and game rules, it should prioritize that move.

**Priority 2 — Capture Opponent’s Piece**
If the AI can move to a space occupied by an opponent’s piece (and the space is **not protected**):

* That move should be chosen.
* Capturing sends the opponent’s piece back to its hand/starting pool.
* Capturing should respect exceptions (e.g., fort spot protection).

**Priority 3 — Exit a Piece**
If the AI can move a piece **off the board (exit)**:

* That move should be chosen.
* Exiting counts toward the win condition (getting all 7 pieces off the board).

**Priority 4 — Advance Closest-to-Exit Piece (Non-Fort)**
If none of the above priorities yield a move:

* AI selects to move the piece **closest to the exit**, based on path distance remaining.
* AI must **not** prefer or select a piece on a **fort** spot for this rule.
* If there are multiple non-fort pieces at the same distance, apply a deterministic tie-breaker (e.g., earliest index, or leftmost on board).

**Priority 5 — Move From Fort Only If**:

* No other rules (1–4) provide a legal move, **or**
* Moving from the fort spot will **capture an opponent’s piece**.

Under these conditions, the AI may:

* Move a piece off the fort according to dice result and legal moves.
* Fort rule still holds: piece on fort is normally protected from being removed by opponent.

If **no legal moves** exist even after evaluating all priorities, AI **skips the turn**.

---

## 4. Special Rules Integration

The existing special spots and rules must be respected by Jimmy:

* **Repeat dice roll spots**:

    * 4th spot in the **entry area**
    * 4th spot in the **community/war area**
    * Spot **before exit**

When Jimmy’s piece lands on any of these spots:

* The game engine should trigger an **extra dice roll** for Player 2.

* Jimmy is then called again to decide a move based on the new dice roll and updated game state.

* **Fort spot (in community/war area)**:

    * A piece on the fort **cannot be removed** by an opponent’s move.
    * AI uses the fort as a strategic safe position.
    * Jimmy should only move a piece off the fort if:

        * No other moves exist (fallback), **or**
        * The move will **capture** an opponent’s piece.

---

## 5. Game Engine Integration Changes

### 5.1 Player Representation

Extend the existing `Player` model or create a flag to indicate control type:

```js
// Example properties
player.isAI = false | true;
player.name = "Player 1" | "Jimmy";
```

When **Play Against AI** mode is selected:

* `Player 1`: `isAI = false`
* `Player 2`: `isAI = true`, `name = "Jimmy"`.

### 5.2 Turn Handling

In the main game loop / turn manager:

1. Determine whose turn it is.
2. If current player `isAI`:

    * Roll dice for AI.
    * Generate legal moves.
    * Call `JimmyAI.chooseMove(gameState, availableMoves)`.
    * Animate and apply the chosen move.
    * Check for repeat-roll conditions or victory.
3. If current player is **human**:

    * Show UI for roll dice.
    * Allow click/tap on pieces and board spaces to choose a move.
    * Validate move via rules engine.

---

## 6. UI/UX Additions

### 6.1 Game Mode Screen UI

* Two large buttons:

    * **Hot Seat**
    * **Play Against AI**
* Optional labels:

    * Subtitle: "Choose how you want to play".

### 6.2 In-Game Indicators

* When playing against AI:

    * Display "Jimmy is thinking..." or similar message during AI turn.
    * Update UI with current player label: `"Your Turn"` vs `"Jimmy’s Turn"`.

---

## 7. Unit Testing Requirements for AI

Extend the test suite to cover AI behavior:

### 7.1 AI Decision Logic Tests

Using **Jest** + **Sinon** (and Mocha/Chai reporters):

* **Priority 1**: When an rosetta move is available, Jimmy chooses it over all other moves.
* **Priority 2**: When a capture move is available, Jimmy chooses a capture over non-capture moves.
* **Priority 3**: When an exit move is possible, Jimmy chooses to exit.
* **Priority 4**: When only advancing moves are left, Jimmy chooses the non-fort piece closest to exit.
* **Priority 5**: Fort piece moves only when no other moves exist or when moving off fort causes a capture.

### 7.2 Edge Cases

* No legal moves → AI returns `null` or a `NO_OP` move.
* Multiple candidate moves within the same priority level → deterministic selection.
* Interaction with repeat-roll spaces (ensure engine re-calls AI after extra roll).

---

This document extends the original Royal Game of War specification with **game mode selection** and **Jimmy AI behavior**. Further refinements can add AI difficulty levels, heuristic weights, or randomness, if desired.
